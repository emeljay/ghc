<!DOCTYPE html>
<html lang="en">
    <head>
	    <link rel="stylesheet" href="activities.css">
    </head>
    <body>
	    <h1> Activity #2 </h1>

	    <h2>Exercise 1: Headers</h2>
	    <p>
			Screen-reader-users rely on screen readers vocalizing what types of elements they are interacting with (e.g. "button" or "header"). Without these vocalizations, it's more difficult for users to make their way around a page and distinguish between different kinds of content.
	    <p>
	    </p>
			Real screenreaders have a variety of keyboard shortcuts used to navigate different kinds of elements on a page (e.g. 'b' might cycle through all buttons, or 'h' through all headers). The heading shortcut is very important for building a mental map of how the page is laid out, and help make the page faster to navigate as users can quickly skip to the content they are interested in. 
		</p>
		<p class="main-task">
		    Use the "heading" button at the bottom of the website to navigate all of the headers on the page. Notice that this allows you to navigate most of the headings on the site -- except for the site title! Take a look at the HTML for the headers that do work to see if you can figure out what's wrong with the site title and fix it.
	    </p>
		
		<button onclick="hideNextNeighbor(this)" aria-expanded="false">Explanation for exercise 1</button>
		<div class="solution" hidden role="presentation">
			<p>
	            Text on a page must be identified as a header for a screen reader to recognize it. In the HTML file (index.html), you'll notice that most header text is wrapped in a header tag (h1, h2, h3, etc). If you wrap the site title in h1 tags, it will become navigable using the "heading" button.
			</p>
			<p>
				Main takeaway: Using proper HTML markup matters!
			</p>
	    </div>
		<h2>Exercise 2: Tabbing</h2>
		<p>
		    Screenreader and non-screenreader-users alike often use tab and shift+tab for navigating between interactive elements. It's important to always make sure that this functionality works correctly in addition to navigating by screenreader shortcuts.
		</p>
		<p class="main-task">
		    Try using the 'tab' key to navigate the demo page. You'll notice that the INSERT ITEM HERE cannot be focused. Compare the untabbable element to other elements on the page and see if you can figure out how to make it tabbable.
		</p>

		<button onclick="hideNextNeighbor(this)" aria-expanded="false">Explanation for exercise 2</button>
		<div class="solution" hidden>
			<p>
				Some elements, such as buttons and form elements, are tabbable/focusable by default. If you want other HTML elements to be tabbable, (e.g. "div" or "span" which are more often text elements not interacted with by mouse or keyboard) you can give them a tabindex attribute.
			</p>
			<p>
				The tabindex HTML attribute defines the navigation order for focusable elements. In addition to giving non-focusable elements the ability to gain focus, it can be used to remove that ability from normally focusable elements.
			</p>
			<p>
				Possible values for the tabindex attribute are:
				<ul>
					<li>
						<div class="code inline">tabindex="1"</div><br />A positive value for the tabindex defines an explicit navigation order, and makes the element focusable if it is not already (not recommended, for reasons described below).
					</li>
					<li>
						<div class="code inline">tabindex="0"</div><br />A tabindex value of 0 does not change the natural navigation order of an element, but makes it focusable if it is not already.
					</li>
					<li>
						<div class="code inline">tabindex="-1"</div><br />A tabindex value of -1 makes an element unable to gain focus using the "tab" key. However, the element can still receive focus programatically, using javascript.
					</li>
				</ul>
			</p>
			<p>
				By default, the navigation order for elements on a page is left-to-right and top-to-bottom. A positive tabindex value allows the natural ordering to be modified. This is not recommended, especially for HTML pages with focusable elements (like buttons or input fields), since it results in unexpected jumps in focus. Imagine if hitting tab caused focus to jump from the start of the page to an element at the very bottom of the page (this is especially jarring for fully or partially-sighted users). Instead of manually changing the natural ordering, the actual HTML structure of the page should modified to produce the desired navigation order. 
			</p>
	    </div>
	

		<h2>Exercise 3: Broken Buttons</h2>
		<p class="main-task">
			Try using the tab key to navigate to the "BUY" buttons. You'll notice that these buttons cannot gain focus. If you hover over one of these buttons with the mouse, you'll also notice that the cursor doesn't change to the "hand" cursor that is typical of buttons. Why do you think this might be? (Take a look at the HTML).
	    </p>
	    <button onclick="hideNextNeighbor(this)" aria-expanded="false">Explanation for exercise 3</button>
		<div class="solution" hidden>
			<p>
				These buttons do not work as expected because they are actually "div" elements styled to look like buttons in CSS, not actual buttons. Try changing the buttons on this website from "div" elements to "button" elements. This includes the submitButton, dialogCloseButton, and all buyButton elements. 
			</p>
			<p>
				Test to see if this worked by using the "tab" key to navigate all buttons. Notice how the screen reader now vocalizes that they are buttons (e.g. "Buy, button")!
			</p>
		</div>

        <h2>Exercise 4: ARIA roles</h2>
        <p class="main-task">
            Sometimes, for whatever reason, you can't use the correct native HTML elements. Sometimes you may need to support legacy browsers that will have issues with the new HTML element, or there are other technical limitations. In these cases, you can use an ARIA role to still get the proper screenreader vocalizations. Let's try it out! Take one of the buttons you modified in exercise 3, change it back to a div, and add <span div="code">aria-role="button"</span> as an attribute. How do you think this might be different from a native button element?
        </p>
        <button onclick="hideNextNeighbor(this)" aria-expanded="false">Explanation for exercise 5</button>
		<div class="solution" hidden>
			<p>
				You'll notice that unlike a div with no aria-role, the screenreader still vocalizes the div as a button. Awesome!
				However, there are several problems with this button:
			</p>
			<ol> 
				<li>The button is not focusable (needs to be fixed with tabindex) </li>
				<li>The button does not have the pointer cursor (needs to be fixed with css)</li>
				<li>The button does not get clicked if the user uses the space key (needs to be fixed by adding a javascript event handler)</li>
		    </ol>
		    <p>
			    Remember that aria labels may change what the screenreader vocalizes, or whether they are navigable using certain screenreader keyboard shortcuts, but they <em>do not affect browser functionality</em>. When you use a role instead of a native element, all the default browser behavior also needs to be replicated. Whenever possible, it's far better to just use a native element instead, which already has all the correct behavior by default. 
			</p>
	    </div>

		<h2>Exercise 5: Visibility</h2>
		<p>
		    You have probably noticed that there's an invisible dialog at the bottom of the screen that gets vocalized even though it's not showing. This is problematic, since non-sighted users will assume that the dialog is visible (and it may not function correctly since the developer did not intend for it to be interacted with in this state), and users with some vision will be confused when an element that they can hear is not visible on the screen.
	    </p>

		<p>
		  Hint: Try taking a look at main.css.
	    </p>

		<p class="main-task">
	      Try hiding the dialog from screenreaders. There are several different solutions!
	    </p>

		<button onclick="hideNextNeighbor(this)" aria-expanded="false">Explanation for exercise 6</button>
		<div class="solution" hidden>
			<p>Three different solutions:</p>
			<ol>
			  <li>
			  	<p>
			  	  Hide completely with CSS: For some reason, the developers of this site used <span class="code inline">z-index:-1</span> to hide the dialog instead of just using <span class="code inline">display:none</span>. Both <span class="code inline">display:none</span> and <span class="code inline">visibility:hidden</span> will hide elements both visually and from screenreaders.
			    </p>
			    <p>
			  	  Lowering opacity to 0, positioning it off-screen, or adjusting z-index to hide it behind something else will not hide it from screenreaders.
			    </p>
			    <p> IMPORTANT: If you used pure CSS to hide the dialog, make sure you modified the hidden class in main.css instead of adding an inline style, so that the dialog will not be hidden when you click the "Buy" button.
			    </p>
			  </li>
			  <li>
			  	Hidden attribute: The HTML <span class="code inline">hidden</span> attribute will similarly hide things both visually and from screenreaders. However, there are some limitations on its intended use; see the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden">MDN documentation</a> for more details. Also, this attribute will need to be added and removed in Javascript when the dialog is shown or hidden.
			  </li>
			  <li>
			  	Hide from screenreaders with aria-hidden: If for some reason display:none or visibility:hidden cannot be used, the element can also be hidden by adding <span class="code inline">aria-hidden="true"</span> to the div. This attribute will need to be added and removed in Javascript when the dialog is shown or hidden.
			  </li>
		    </ol>
	    </div>
	
		<h2>Exercise 6: Dialogs</h2>
		<p>
			Using a screen reader, navigate to the "buy" dialog and tab through the various input fields inside the dialog. You'll notice a few issues with navigating the dialog using the screen reader, such as:
		
			<ol>
				<li>
				  There is no indication or announcement by the screen reader when the dialog opens.</li>
				<li>
				  Focus is mismanaged. Once the dialog opens, focus is still unexpectedly in the background of the page.
				</li>
			</ol>
		</p>
		<p class="main-task">
			Fix the dialog using a combination of HTML and JavaScript.
		</p>
		
		<button onclick="hideNextNeighbor(this)" aria-expanded="false">Explanation for exercise 6</button>
		<div class="solution" hidden>
			<p>
				To fix this, the dialog must have correct labels and keyboard focus must be properly handled. Let's start by learning how to add proper labels to the dialog. First, a dialog must have the role="dialog" attribute. For sighted users, the dialog is labelled by its title. For screen readers to also be able to associate the dialog with its title, 

				TODO!!! (follow steps here: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_dialog_role)

				draft/notes:
				You'll notice that focus is still unexpectedly in the background of the page, rather than inside this dialog. To fix this, we're going to need to 1) make the dialog focusable and 2) use javascript to draw focus to the dialog, and then restore focus to the main page after the dialog has been closed. 

				Try adding the tabindex attribute to the "buyDialog" to make it focusable using javascript. In javascript, modify the showDialog function so that the dialog receives focus when it is shown.

				If time permits at the end of this workshop, try adding javascript to restore focus to the last focused element on the mainPage once the dialog closes. Hint: You'll have to keep track of the currently focused element when the dialog pops up and make modifications to the hideDialog function to restore focus.


				Marking a dialog with this aria role allows assistive technologies to identify and differentiate content inside the dialog from the rest of the page.
		    </p>
		</div>
		
		<p>
			To learn more about accessibility with dialogs, visit https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_dialog_role.
		</p>

		<h2>Bonus Exercise 7: Advanced ARIA</h2>
		<p>
			ARIA comes in very handy when you're implementing a complex widget for which no native markup exists. For instance, if you're implementing a slider or an autocomplete, you need some way of concisely communicating to the user what the widget does and how to interact with it. 

			You'll notice that at the bottom of the "BUY" dialog is a tab widget. However, without aria roles and properties, screenreader users may not know how to interact with it. Using the ARIA spec, try adding the proper ARIA markup! Hint: You'll need to use javascript to update the markup when the tab selection changes.
		</p>

	    <h2>Bonus Exercise 8: Color contrast</h2>
		<p>
			Even though we've fixed the functionality of the buttons, they're still not quite fully accessible due to their low color contrast. The gray text (#808080) is difficult to discern from the blue (#0000FF) background. To learn more, check out the <a href="https://webaim.org/resources/contrastchecker/">WebAIM Contrast Checker</a>. Try different color combinations and modify the color or background-color attributes on the buttons to get a better color contrast ratio!
		</p>
		<blockquote>
			<p>
			  WCAG 2.0 level AA requires a contrast ratio of at least 4.5:1 for normal text and 3:1 for large text. Level AAA requires a contrast ratio of at least 7:1 for normal text and 4.5:1 for large text.
		    </p>
   			<p>
			  Large text is defined as 14 point (typically 18.66px) and bold or larger, or 18 point (typically 24px) or larger.
		    </p>
		    <p>
			   source: <a href="https://webaim.org/resources/contrastchecker/">https://webaim.org/resources/contrastchecker/</a>
		    </p>
		</blockquote>
		<p>
			Don't be afraid to push back on designs that use colors that have color contrast ratios that are too low!
		</p>

		<h2>Learn more</h2>
		<p>
		  If you'd like to learn more about how to create accessible web components, visit the <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">MDN documentation on ARIA techniques</a>.
	    </p>

		<script>
          function hideNextNeighbor(button) {
          	const neighbor = button.nextElementSibling;
          	let isExpanded = button.getAttribute('aria-expanded') === 'true';
          	neighbor.hidden = isExpanded;
          	button.setAttribute('aria-expanded', !isExpanded);
          }
         </script>

	</body>
</html>